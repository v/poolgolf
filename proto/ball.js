// Generated by CoffeeScript 1.6.3
var Ball,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

goog.provide('game.Ball');

goog.require('lime');

goog.require('lime.Circle');

goog.require('lime.Sprite');

goog.require('game');

Ball = (function(_super) {
  __extends(Ball, _super);

  function Ball(position, color) {
    this.position = new goog.math.Vec2(position[0], position[1]);
    this.velocity = new goog.math.Vec2(0, 0);
    this.radius = game.ball_radius;
    this.shape = new lime.Circle().setSize(this.radius * 2, this.radius * 2).setPosition(this.position.x, this.position.y);
    if (!color) {
      color = game.ball_color;
    }
    this.shape.setFill(color);
    this.next_collision = 0;
    lime.scheduleManager.schedule(this.step_, this);
    game.target.appendChild(this.shape);
  }

  Ball.prototype.collidesBall = function(other) {
    var mine, theirs;
    mine = this.position.clone();
    theirs = other.position.clone();
    mine.subtract(theirs);
    return mine.magnitude() <= this.radius * 2;
  };

  Ball.prototype.step_ = function(dt) {
    var dist, dvel, wall, _i, _len, _ref;
    dist = this.velocity.clone().scale(dt / 1000);
    this.position.add(dist);
    dvel = game.gravity.clone().scale(dt / 1000);
    this.velocity.add(dvel);
    this.shape.setPosition(this.position.x, this.position.y);
    if (this.velocity.magnitude() > game.max_speed) {
      this.velocity.normalize().scale(game.max_speed);
    }
    if (this.velocity.magnitude() < game.min_speed) {
      this.velocity.x = 0;
      this.velocity.y = 0;
    }
    this.velocity.scale(0.995);
    _ref = game.board.walls;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      wall = _ref[_i];
      if (this.next_collision === 0 && wall.collidesCircle(this.position, this.radius)) {
        this.next_collision = 4;
        if (wall.direction === 'x') {
          this.velocity.y *= -game.wall_restitution;
        }
        if (wall.direction === 'y') {
          this.velocity.x *= -game.wall_restitution;
        }
        console.log(wall.layer.getPosition().toString());
      }
    }
    if (this.next_collision > 0) {
      this.next_collision -= 1;
    }
    return this;
  };

  Ball.prototype.applyForce = function(vec) {
    vec.scale(3);
    return this.velocity.add(vec);
  };

  return Ball;

})(lime.Sprite);

game.Ball = Ball;
